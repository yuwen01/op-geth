package eth

import (
	"context"
	"errors"
	"fmt"

	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/core/types/interoptypes"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/ethereum/go-ethereum/internal/ethapi"
)

func (s *Ethereum) CheckMessages(ctx context.Context, messages []interoptypes.Message, minSafety interoptypes.SafetyLevel) error {
	if s.interopRPC == nil {
		return errors.New("cannot check interop messages, no RPC available")
	}
	return s.interopRPC.CheckMessages(ctx, messages, minSafety)
}

// SimLogs simulates the logs that would be generated by a transaction if it were executed on the current state.
// This is used by the interop filter to determine if a transaction should be allowed.
// if errors are encountered, no logs are returned.
func (s *Ethereum) SimLogs(tx *types.Transaction) ([]*types.Log, error) {
	chainConfig := s.APIBackend.ChainConfig()
	if !chainConfig.IsOptimism() {
		return nil, errors.New("expected OP-Stack chain config, SimLogs is an OP-Stack feature")
	}
	header := s.BlockChain().CurrentBlock()
	if chainConfig.InteropTime == nil {
		return nil, errors.New("expected Interop fork to be configured, SimLogs is unavailable pre-interop")
	}
	state, err := s.BlockChain().StateAt(header.Root)
	if err != nil {
		return nil, fmt.Errorf("state %s (block %d) is unavailable for log simulation: %w", header.Root, header.Number.Uint64(), err)
	}
	var vmConf vm.Config
	signer := types.MakeSigner(chainConfig, header.Number, header.Time)
	message, err := core.TransactionToMessage(tx, signer, header.BaseFee)
	if err != nil {
		return nil, fmt.Errorf("cannot convert tx to message for log simulation: %w", err)
	}
	chainCtx := ethapi.NewChainContext(context.Background(), s.APIBackend)
	blockCtx := core.NewEVMBlockContext(header, chainCtx, &header.Coinbase, chainConfig, state)
	vmenv := vm.NewEVM(blockCtx, state, chainConfig, vmConf)
	state.SetTxContext(tx.Hash(), 0)
	result, err := core.ApplyMessage(vmenv, message, new(core.GasPool).AddGas(header.GasLimit))
	if err != nil {
		return nil, fmt.Errorf("failed to execute tx: %w", err)
	}
	if result.Failed() { // failed txs do not have log events
		return nil, nil
	}
	return state.GetLogs(tx.Hash(), header.Number.Uint64(), header.Hash()), nil
}
